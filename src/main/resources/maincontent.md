## 1 设计模式入门

软件开发的真理是，世界在变，不管当初的设计多么好，一段时间过后，总是需要成长和改变，否则软件就会死亡；

凡是OO都会用到，除了**4个OO基本概念**，抽象，封装，继承，多态，

还有**9个OO原则**；OO原则是我们的目标，而设计模式是我们的做法；

**设计原则1**：找出应用中可能需要变化的地方，把他们独立出来，不要和那些不需要变化的代码混在一起；把会变化的部分取出来，封装起来，好让其他部分不会受到影响；代码引起的变化越少，系统变得越有弹性；

**设计原则2**：针对接口编程，而不是针对实现编程；这里的接口是广义的，不是就是java中的interface

**设计原则3**：多用组合，少用继承；使用组合建立系统有很大的弹性，可以将算法封装成族，可以再运行时改变行为等等；

**策略模式**：定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户；

工程师之间的交流，会有很多共享的语言，就像行话或者黑话，之间沟通的效率会大大提高；

设计模式的思想层次比库和框架要高，库是复用别人的代码，节省开发的时间，方便编码实践，是开发过程的一部分；但是库没有办法帮我们组织程序架构这个开发设计层次的事情需要设计模式来帮助我们，复用之前大神们的经验和良好实践，也就时复用架构，复用思想；

## 2 观察者模式 Observer

观察者模式 = 出版者（Subject） + 订阅者（Observer）；

**观察者模式**：定义了对象之间一对多的依赖，当那一个对象改变状态的时候，他的所有依赖者都会收到通知并自动更新；

**松耦合**；当两个对象之间松耦合，他们之间依然可以交互，但是不清楚彼此的细节；观察者模式让主题和观察者之间松耦合；这样可以为系统带来弹性，更加可以应对变化，因为对象之间的互相依赖降到了最低；

**设计原则4**；为了交互对象之间的松耦合设计而努力；

JavaAPI中内置了一个观察者模式的实现，Observable类和Observer接口；Observable类实现了需要维护观察者列表，增加删除和广播的方法，还有一些其他的功能；在通知观察者之前，需要调用setChanged方法来表示状态已经被更新过了；

## 3 装饰者模式 Decorator

目前可以公开的信息；
装饰者和被装饰者具有相同的超类型；
可以使用一个或者多个装饰者包装一个对象；
既然装饰者和被装饰者的类型一直，那么只要是被装饰者在的地方就可以被装饰者替换；
装饰者可以在所委托被装饰者的行为之前或者之后，加上自己的行为，来达到特定的目的；
对象可以在任何时候被装饰，所以可以在运行时动态，不限量地用你喜欢的的装饰者来装饰对象；

**装饰者模式**：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案；

所有的装饰者和被装饰者都是扩展自一个基础类型，比如继承自一个抽象类，那么实际上就可以认为是一类对象；装饰者的构造器参数就是基类的对象，在本身需要装饰的行为中，调用基类对象的行为，实际上装饰器就可以替代那个需要被装饰的类，因为行为只多不少；

用一个实例变量记录被装饰者；设法把被装饰者传入装饰者，比如座位构造器的参数传入；

装饰者的真实应用，Java IO；io库当中的类茫茫多，但是很多都是装饰器，加上了按行读取或者加上行数这样的功能；

## 4 工厂模式

看到new关键字的时候，就会想到具体实现，不符合面向接口的设计原则；

封装创建对象的代码；简单工厂并不是一个正式的设计模式，只是名义上的，可以看作是从客户代码中去除实例化代码的一种编程习惯；仅仅封装了创建对象部分的代码而已；

**工厂方法模式**；定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类；

让子类决定的意思不是真的吧主动权交给子类，而是接口并不知道当时实现的到底是什么具体类型；

首先是一个抽象的创建者类座位抽象类被继承，定义了一个抽象的工厂方法，让子类来实现具体的创建过程；这里创建的产品也都是抽象产品，具体的产品也是由具体的创建者子类进行创建；另一条线上的产品类，一个抽象接口定义了产品的基本要素，之后具体的产品由他的子类来实现

**设计原则**；要依赖抽象，不要依赖具体类；依赖倒置原则，代码里减少对具体类的依赖；不管高层还是低层组件，都应该依赖于抽象；

依赖倒置原则的具体方针；变量不可以持有具体类的引用，可以改用工厂来改变做法；不要让类派生自具体类，派生自一个抽象；不要覆盖基类中已经实现的方法；

**抽象工厂模式**；提供一个接口，用于创建相关或以来对象的家族，而不需要明确指定具体类；

抽象工厂中，包含了多个工厂方法，创建很多其他的具体类；抽象工厂是创建了一系列类的家族，接口中可以创建很多产品；

抽象工厂和工厂方法的作用都是创建对象，但是工厂方法使用的是继承，抽象工厂使用的是组合；

利用工厂方法创建对象，需要扩展一个类，并覆盖它的工厂方法，使用子类来创建对象，客户只需要知道所使用的抽象类型就好，不用管具体是什么子类型；子类来负责创建具体类型，将客户从具体类型中解耦；

抽象工厂创建了一个抽象类型，定义了很多创建产品的抽象类型，这个类型的子类定义了产品被产生的方法；

## 5 单件模式

**单件模式**：确保一个类只有一个实例，并提供一个全局访问点；

初步的单间实现会在多线程的环境下出现问题；三种方式解决多线程造成的问题，同步的getInstance方法，急切实例化，和双重检查加锁；

## 6 命令模式

把封装带到一个全新的境界，把方法调用封装起来；将发出请求的对象和接受和执行这些请求的对象分割开来；

**命令模式**：将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销操作；