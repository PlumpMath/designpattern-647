## 1 设计模式入门

软件开发的真理是，世界在变，不管当初的设计多么好，一段时间过后，总是需要成长和改变，否则软件就会死亡；

凡是OO都会用到，除了**4个OO基本概念**，抽象，封装，继承，多态，

还有**9个OO原则**；OO原则是我们的目标，而设计模式是我们的做法；

**设计原则1**：找出应用中可能需要变化的地方，把他们独立出来，不要和那些不需要变化的代码混在一起；把会变化的部分取出来，封装起来，好让其他部分不会受到影响；代码引起的变化越少，系统变得越有弹性；

**设计原则2**：针对接口编程，而不是针对实现编程；这里的接口是广义的，不是就是java中的interface

**设计原则3**：多用组合，少用继承；使用组合建立系统有很大的弹性，可以将算法封装成族，可以再运行时改变行为等等；

**策略模式**：定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户；

工程师之间的交流，会有很多共享的语言，就像行话或者黑话，之间沟通的效率会大大提高；

设计模式的思想层次比库和框架要高，库是复用别人的代码，节省开发的时间，方便编码实践，是开发过程的一部分；但是库没有办法帮我们组织程序架构这个开发设计层次的事情需要设计模式来帮助我们，复用之前大神们的经验和良好实践，也就时复用架构，复用思想；

## 2 观察者模式 Observer

观察者模式 = 出版者（Subject） + 订阅者（Observer）；

**观察者模式**：定义了对象之间一对多的依赖，当那一个对象改变状态的时候，他的所有依赖者都会收到通知并自动更新；

**松耦合**；当两个对象之间松耦合，他们之间依然可以交互，但是不清楚彼此的细节；观察者模式让主题和观察者之间松耦合；这样可以为系统带来弹性，更加可以应对变化，因为对象之间的互相依赖降到了最低；

**设计原则4**；为了交互对象之间的松耦合设计而努力；

JavaAPI中内置了一个观察者模式的实现，Observable类和Observer接口；Observable类实现了需要维护观察者列表，增加删除和广播的方法，还有一些其他的功能；在通知观察者之前，需要调用setChanged方法来表示状态已经被更新过了；

## 3 装饰者模式 Decorator

目前可以公开的信息；
装饰者和被装饰者具有相同的超类型；
可以使用一个或者多个装饰者包装一个对象；
既然装饰者和被装饰者的类型一直，那么只要是被装饰者在的地方就可以被装饰者替换；
装饰者可以在所委托被装饰者的行为之前或者之后，加上自己的行为，来达到特定的目的；
对象可以在任何时候被装饰，所以可以在运行时动态，不限量地用你喜欢的的装饰者来装饰对象；

**装饰者模式**：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案；

所有的装饰者和被装饰者都是扩展自一个基础类型，比如继承自一个抽象类，那么实际上就可以认为是一类对象；装饰者的构造器参数就是基类的对象，在本身需要装饰的行为中，调用基类对象的行为，实际上装饰器就可以替代那个需要被装饰的类，因为行为只多不少；

用一个实例变量记录被装饰者；设法把被装饰者传入装饰者，比如座位构造器的参数传入；

装饰者的真实应用，Java IO；io库当中的类茫茫多，但是很多都是装饰器，加上了按行读取或者加上行数这样的功能；

## 4 工厂模式

看到new关键字的时候，就会想到具体实现，不符合面向接口的设计原则；

封装创建对象的代码；简单工厂并不是一个正式的设计模式，只是名义上的，可以看作是从客户代码中去除实例化代码的一种编程习惯；仅仅封装了创建对象部分的代码而已；

**工厂方法模式**；定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类；

让子类决定的意思不是真的吧主动权交给子类，而是接口并不知道当时实现的到底是什么具体类型；

首先是一个抽象的创建者类座位抽象类被继承，定义了一个抽象的工厂方法，让子类来实现具体的创建过程；这里创建的产品也都是抽象产品，具体的产品也是由具体的创建者子类进行创建；另一条线上的产品类，一个抽象接口定义了产品的基本要素，之后具体的产品由他的子类来实现

**设计原则**；要依赖抽象，不要依赖具体类；依赖倒置原则，代码里减少对具体类的依赖；不管高层还是低层组件，都应该依赖于抽象；

依赖倒置原则的具体方针；变量不可以持有具体类的引用，可以改用工厂来改变做法；不要让类派生自具体类，派生自一个抽象；不要覆盖基类中已经实现的方法；

**抽象工厂模式**；提供一个接口，用于创建相关或以来对象的家族，而不需要明确指定具体类；

抽象工厂中，包含了多个工厂方法，创建很多其他的具体类；抽象工厂是创建了一系列类的家族，接口中可以创建很多产品；

抽象工厂和工厂方法的作用都是创建对象，但是工厂方法使用的是继承，抽象工厂使用的是组合；

利用工厂方法创建对象，需要扩展一个类，并覆盖它的工厂方法，使用子类来创建对象，客户只需要知道所使用的抽象类型就好，不用管具体是什么子类型；子类来负责创建具体类型，将客户从具体类型中解耦；

抽象工厂创建了一个抽象类型，定义了很多创建产品的抽象类型，这个类型的子类定义了产品被产生的方法；

## 5 单件模式

**单件模式**：确保一个类只有一个实例，并提供一个全局访问点；

初步的单间实现会在多线程的环境下出现问题；三种方式解决多线程造成的问题，同步的getInstance方法，急切实例化，和双重检查加锁；

## 6 命令模式

把封装带到一个全新的境界，把方法调用封装起来；将发出请求的对象和接受和执行这些请求的对象分割开来；

**命令模式**：将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销操作；

对象可以被传递，订单对象作为餐厅中的对象被顾客服务员和厨师处理；

![](http://ww1.sinaimg.cn/large/8d6a2535gw1faci9ljcxtj20od0lxn04.jpg)

模式荣誉奖；**空对象模式**，不想返回一个null引用的时候，可以返回一个空对象，返回一个没有意义的对象；

宏命令即是命令的集合，命令的命令；

## 7 适配器模式与外观模式

从现实世界中的例子来讲，所有的充电器，转接头都是用了适配器模式的思想，墙壁上的插座不能直接给我的手机充电，我使用充电器来把交流电220伏特的电源转接成5伏特的电源来给我自己的设备充电；

客户代码使用适配器的方式：

1. 客户通过目标接口调用适配器方法对适配器发出请求
2. 适配器使用被适配的接口把请求转化成为被适配者的一个或者多个调用接口；
3. 客户接收到调用的结果，但是并没有察觉这一切是适配器在起转换作用；

**适配器模式**：将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间；

对象适配器和类适配器，使用不同的适配方法，上面的是对象适配器，使用组合实现，类适配器使用继承实现；

真实世界的例子，早期Java的集合类型中的枚举接口，枚举接口会遍历集合中的所有元素，但是不用担心怎么实现；新的Java版本中的迭代器，和枚举很相似；可以使用适配器来将老的Enumeration接口适配迭代器Iterator；

外观模式：目的是为了复杂接口的使用更加简化；但也只是提供简化的操作，并没有屏蔽更加低层的操作；实际效果上，不仅仅是简化了接口，也把客户从组件的子系统中解耦；

**外观模式**：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用；

**设计原则**；最少知识原则：只和你的密友谈话，减少对象之间的交互；

最小知识原则的方针，对任何对象而言，在对象方法内，调用的方法最好仅限于；

1. 该对象本身
2. 被当做方法的参数而传递进来的对象
3. 此方法创建或者实例化的任何对象
4. 对象的任何组件，组合来的实例变量

最小知识原则也叫作，Law of Demeter，德模特法则，一个意思

## 8 模板方法模式

模板方法定义了一个算法的步骤，并允许子类为一个或者多个步骤提供实现，封装算法的基本结构，一些可定义的细节交给子类来实现；

将多个算法的步骤抽象成一个抽象父类，前提是子类们的算法步骤都是类似的，抽象父类负责框架流程，子类负责某些步骤的实现；

**模板方法模式**：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类当中。模板方法使得子类可以再不改变算法机构的情况下，重新定义算法中的某些步骤；

钩子方法，hook，被声明在抽象类中的方法，但是只有空的或者默认的实现；让子类决定是否去覆盖，挂钩，自己决定；加了钩子之后的模板方法，子类通过覆盖父类的方法，来达到影响算法流程细节的目的；

**设计原则**：好莱坞原则，别调用（打电话给）我们，我们会调用（打电话给）你；避免环状依赖，循环依赖；

JDK中的Arrays.sort方法，是一种算法封装的模板方法的思想体现，数组的元素实现Comparable接口，实现compareTo方法，实际上子类实现的是算法中如何定义元素比较大小的步骤的定义；

## 9 迭代器与组合模式

把对象堆起来成为一个集合的方法有很多，p316